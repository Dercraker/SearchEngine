// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ClaimNextBatch.sql

package DAL

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const claimNextBatch = `-- name: ClaimNextBatch :many
WITH picked AS (SELECT id
                FROM crawl_queue
                WHERE next_run_at <= now()
                  AND status IN ('pending', 'failed')
                ORDER BY next_run_at ASC
    LIMIT $1
    FOR
UPDATE SKIP LOCKED
    )
UPDATE crawl_queue q
SET status     = 'processing',
    locked_at  = now(),
    updated_at = now() FROM picked
WHERE q.id = picked.id
    RETURNING q.id
    , q.url
    , q.status
    , q.attempts
    , q.next_run_at
    , q.last_error
`

type ClaimNextBatchRow struct {
	ID        uuid.UUID
	Url       string
	Status    string
	Attempts  int32
	NextRunAt time.Time
	LastError sql.NullString
}

func (q *Queries) ClaimNextBatch(ctx context.Context, limit int32) ([]ClaimNextBatchRow, error) {
	rows, err := q.db.QueryContext(ctx, claimNextBatch, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClaimNextBatchRow
	for rows.Next() {
		var i ClaimNextBatchRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Status,
			&i.Attempts,
			&i.NextRunAt,
			&i.LastError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
