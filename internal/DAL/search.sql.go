// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: search.sql

package DAL

import (
	"context"
	"database/sql"
)

const searchDocuments = `-- name: SearchDocuments :many
SELECT dt.title AS title,
       d.url    AS url,
       ts_rank(
               ds.search_vector,
               websearch_to_tsquery('simple', $1)
       ) ::float8 AS score
FROM public.document_search ds
         JOIN public.documents d
              ON d.id = ds.document_id
         LEFT JOIN public.document_text dt
                   ON dt.document_id = d.id
WHERE ds.search_vector @@ websearch_to_tsquery('simple', $1)
ORDER BY score DESC, d.fetched_at DESC
    LIMIT $3
OFFSET $2
`

type SearchDocumentsParams struct {
	Q          string
	PageOffset int32
	PageLimit  int32
}

type SearchDocumentsRow struct {
	Title sql.NullString
	Url   string
	Score float64
}

func (q *Queries) SearchDocuments(ctx context.Context, arg SearchDocumentsParams) ([]SearchDocumentsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchDocuments, arg.Q, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchDocumentsRow
	for rows.Next() {
		var i SearchDocumentsRow
		if err := rows.Scan(&i.Title, &i.Url, &i.Score); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
